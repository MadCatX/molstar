/**
 * Copyright (c) 2019-2020 mol* contributors, licensed under MIT, See LICENSE file for more info.
 *
 * @author Michal Malý (michal.maly@ibt.cas.cz)
 * @author Jiří Černý (jiri.cerny@ibt.cas.cz)
 */

import { StructureElement } from '../../mol-model/structure';
import { OrderedSet, SortedArray } from '../../mol-data/int';

export namespace StepSlider {
    function move(loci: StructureElement.Loci, by: number) {
        /*
         * Okay, stop reading the code and focus! I mean it!
         * Here is how this works in Molstar.
         * - A structure is composed of units.
         * - Each unit contains an ordered array of elements.
         * - Elements are the smallest pieces a structure can be divided up to.
         * - Array of elements contains items of type "ElementIndex"
         * - The array of elements is implemented as an "OrderedSet"
         * - "ElementIndex"es are values of that "OrderedSet", the keyes (or indices, if you want) are of type "UnitIndex"
         * - Value of "ElementIndex" is used to query information about a given element.
         * Following the standard structural biology taxonomy, elements can be grouped to residues and chains.
         * Molstar implements this grouping by means of "Segmentation" objects.
         * "Segmentation" provides mapping of group index to "ElementIndex". In contains two fields of interest.
         * - "offset" field maps a group index to "ElementIndex" of the first element that belongs to that group.
         * - "index" field maps "ElementIndex" to a group index.
         * A concrete example for residues: If you have an "ElementIndex" and you want to know the corresponding "ResidueIndex",
         * use the "index" field from "residueAtomSegments". If you have a "ResidueIndex" rI,
         * use the "offsets" field at offsets[rI] and offsets[rI + 1] to get the range of "ElementIndex"es for the given residue.
         *
         * Keep in mind that neiter "ChainIndex", "ResidueIndex", nor "ElementIndex" correspond to any human-readable identifiers
         * of the components if the structure. They are only internal indices generated by Molstar.
         *
         * That wasn't so hard, was it?
         *
         * Also, you do not get to yell at me when this information turns out to be inaccurate because either Molstar changes
         * its internal representation or my reverse engineering of this logic that is not explained anyhere turns out to be imprecise!
         */

        const elem = loci.elements[0];
        const unit = elem.unit;
        const { offsets: residueOffsets, index: residueIndices } = unit.model.atomicHierarchy.residueAtomSegments;
        const { offsets: chainOffsets, index: chainIndices } = unit.model.atomicHierarchy.chainAtomSegments;

        // We need this to query alt_id value of an element
        const { label_alt_id } = elem.unit.model.atomicHierarchy.atoms;

        const eI = unit.elements[OrderedSet.getAt(elem.indices, 0)];

        // First find out which chain our element belongs to.
        const cI = chainIndices[eI];
        // First element of that chain
        const eIFirst = chainOffsets[cI];
        const eILast = cI === chainOffsets.length - 1 ? unit.elements[unit.elements.length - 1] : chainOffsets[cI + 1] - 1;

        // Find what residue we belong to and move to the desired residue
        const rI = residueIndices[eI] + by;

        if (rI < 0 || rI >= residueOffsets.length)
            return undefined; // We cannot go outside the structure
        // Now check that we did not move outside the chain - we do not want this to happen here
        if (residueOffsets[rI] < eIFirst || residueOffsets[rI] > eILast)
            return undefined;

        const firstAltId = label_alt_id.value(eI);
        const eITo = rI >= residueOffsets.length ? unit.elements.length - 1 : residueOffsets[rI + 1];
        const newIndices: StructureElement.UnitIndex[] = [];
        for (let _eI = residueOffsets[rI]; _eI < eITo; _eI++) {
            const idx = OrderedSet.indexOf(unit.elements, _eI); // We need to convert ElementIndex to UnitIndex
            if (idx >= 0) {
                const altId = label_alt_id.value(eI);
                if (firstAltId === '' || altId === firstAltId || altId === '') {
                    newIndices[newIndices.length] = idx as StructureElement.UnitIndex;
                }
            }
        }

        const newElements: StructureElement.Loci['elements'][0][] = [];
        newElements[newElements.length] = { unit: elem.unit, indices: SortedArray.ofSortedArray(newIndices) };

        // Now we construct a new Loci that is made up of all elements of the residue we moved to
        // Only elements with matching alt_id are included
        return StructureElement.Loci(loci.structure, newElements);
    }

    export function nextResidue(loci: StructureElement.Loci) {
        return move(loci, 1);
    }

    export function nextStep(loci: StructureElement.Loci) {
        return move(loci, 2);
    }
}
